#!/usr/bin/python

'''
This contains the class and functions for golems.

Golems are creatures that automatically strike at mines. To create one, a player
creates a golem shape by making ascii art with resources they currently have.
The golem's stats depend on its initial shape, with some amount of
randomization. Once created, a golem immediately begins working in the player's
currently targetted mine.

When the golem's lifespan ends, it crumbles, and all the resources it mined are
entered into the player's holdings.

Golems will never take mysterious smoke from the mines, nor will they switch
mines automatically.

plaintxtmines is a text-based multiplayer mining simulator. For more
information, see the full repository:

https://github.com/modgethanc/plaintxtmines
'''

__author__ = "Vincent Zeng (hvincent@modgethanc.com)"

import os
import random

import vtils

import players
import mines

j = ','

class Golem():
    '''
    Implements a golem object.
    '''

    def __init__ (self):
        '''
        Initial golem conditions.
        '''

        ## given stats
        self.core = None
        self.birth = None
        self.owner = None

        ## calculated stats
        self.interval = None
        self.height = None
        self.width = None

        ## depends on self.height
        self.strength = None

        ## depends on self.strength
        self.death = None

        ## mutables
        self.shape = ""
        self.lastStrike = 0
        self.res = [0,0,0,0,0,0,0,0]
        #self.res = "0,0,0,0,0,0,0,0"


    def load(self, player):
        '''
        Loads a golem from file for the named player, then returns that player's
        name to identify the new golem's owner.
        '''

        filename = player + ".golem"

        # hardcode bs
        golemData = vtils.open_json_as_dict("../data/"+filename)

        ## given stats
        self.core = golemData["core"]
        self.birth = golemData["birth"]
        self.owner = golemData["owner"]

        ## calculated stats
        self.interval = golemData["interval"]
        self.height = golemData["height"]
        self.width = golemData["width"]

        ## depends on self.height
        self.strength = golemData["strength"]

        ## depends on self.strength
        self.death = golemData["death"]

        ## mutables
        self.shape = golemData["shape"]
        self.lastStrike = golemData["lastStrike"]
        self.res = golemData["res"]

        return player

    def create(self, player_input, golemString):
        '''
        Create a new golem, using inputs from a player command.
        '''

        ## given stats
        self.core = self.parse(golemString)
        self.birth = player_input.timestamp
        self.owner = player_input.nick
        self.shape = golemString
        self.lastStrike = player_input.timestamp

        ## calculated stats
        self.interval = self.calc_interval()
        self.height = self.calc_height()
        self.width = self.calc_width()

        ## depends on self.height
        self.strength = self.calc_strength()

        ## depends on self.strength
        self.death = self.calc_death(self.birth)

    def save(self):
        '''
        Writes this golem to disk and returns its save location.
        '''

        # hardcode bs
        filename = "../data/" + self.owner + ".golem"
        golemData = self.to_dict()
        vtils.write_dict_as_json(filename, golemData)

        return filename

    def to_dict(self):
        '''
        Turns all data into a dict.
        '''

        golemData = {
                "core": self.core,
                "birth": self.birth,
                "owner": self.owner,
                "interval": self.interval,
                "height": self.height,
                "width": self.width,
                "strength": self.strength,
                "death": self.death,
                "shape": self.shape,
                "lastStrike": self.lastStrike,
                "res": self.res
                }

        return golemData

    def parse(self, golemstring):
        '''
        Takes a golem string (usually generated by a player) and parses it into
        a dict that counts up each of the components of the golem.
        '''

        golemCore = {
                "~": 0,
                "#": 0,
                "@": 0,
                "&": 0,
                "*": 0,
                "[": 0,
                "]": 0,
                "^": 0
                }
        components = list(golemstring)

        for res in components:
            golemCore[res] += 1

        return golemCore

    ## stat formulas

    def calc_interval(self):
        '''
        Returns a strike interval roll between 1 and 200 seconds, based on the
        number of ampers in the golem.
        '''

        return 200/max(1, min(int(self.core["&"]), 100))

    def calc_height(self):
        '''
        Returns the height of the golem, which is just a sum of all of its
        parts.
        '''

        total = 0
        for res in iter(self.core):
            total += int(self.core[res])

        return total

    def calc_strength(self):
        '''
        Returns a strength roll for a golem, which is based on its height and
        the number of pounds it contains (to a maximum of 10 pounds).

        CAUTION: This assumes the height has already been set!
        '''

        return self.height * random.randrange(1, max(2, min(int(self.core["#"]), 10)))

    def calc_width(self):
        '''
        Returns the width of the golem, which is a count of how many different
        types of resources it contains.
        '''

        width = 0

        for res in self.core:
            if int(self.core[res]) > 0:
                width += 1

        return width

    def calc_death(self, timestamp):
        '''
        Takes a golem core and a timestamp and performs a diceroll to determine
        its lifespan, and returns a timestamp for when it will die. The golem's
        tail is based on the number of tildes it contains, which
        slightly influence its lifespan.

        CAUTION: This assums the strength has already been set!
        '''

        death = timestamp
        tail = int(self.core["~"]) * random.randrange(1,10)
        life = 100 * random.randrange(1, max(self.strength, 2)) + tail
        death = int(timestamp) + life

        return death

    ## inquiries

    def remaining_life(self, timestamp):
        '''
        Return the golem's remaining number of seconds until death.
        '''

        """ toggle for debug
        print "death: " + str(self.death)
        print "now:   " + str(timestamp)
        print "diff:  " + str(self.death-timestamp)
        """

        return self.death - int(timestamp)

    def is_alive(self, timestamp):
        '''
        Returns true if the golem is alive, false otherwise.
        '''

        return self.remaining_life(timestamp) > 0

    def readable_holdings(self):
        '''
        Returns a human-readable string of the golem's held resources.
        '''

        #held = self.res.split(",")

        held = self.res

        heldTotal = 0
        for res in held:
            heldTotal += int(res)

        i = 0
        while i < 8: # stupid string hax
            r = str(held[i])
            held[i] = r
            i += 1

        return held[0]+ " tilde, "+held[1]+ " pound, "+held[2]+ " spiral, "+held[3]+ " amper, "+held[4]+ " splat, "+held[5]+ " lbrack, "+held[6]+ " rbrack, and "+held[7]+" carat, for a total of "+str(heldTotal)+" units"
        #return held[0]+ " tilde, "+held[1]+ " pound, "+held[2]+ " spiral, "+held[3]+ " amper, "+held[4]+ " splat, "+held[5]+ " lbrack, "+held[6]+ " rbrack, and "+held[7]+" carat, for a total of "+str(heldTotal)+" units"

    ## actions

    def strike(self, targetMine, elapsed):
        '''
        Strikes at targetted mine and adds resources to own held, then updates
        last strike time.
        '''

        excavation = mines.excavate(targetMine, self.strength, self.width)
        held = self.res

        i = 0
        for resType in excavation:
            newTotal = int(held[i]) + int(resType)
            held[i] = newTotal
            i += 1

        self.lastStrike = elapsed

        return excavation

    def expire(self):
        '''
        Destroys this golem and returns a list of its resources.
        '''

        ## hardcoded
        os.remove("../data/"+self.owner+".golem")

        return self.res

    ## legacy

    def legacy_stats(self):
        '''
        Intermediate function, to return a string list of this golem's
        resources.
        '''

        '''
        return ",".join([
                str(self.core["~"]),
                str(self.core["@"]),
                str(self.core["#"]),
                str(self.core["&"]),
                str(self.core["&"]),
                str(self.core["*"]),
                str(self.core["["]),
                str(self.core["]"])])
        '''
        return [
                self.core["~"],
                self.core["@"],
                self.core["#"],
                self.core["&"],
                self.core["*"],
                self.core["["],
                self.core["]"],
                self.core["^"]]

## golem helpers

def sift(rawGolem):
    '''
    Takes a raw golem and removes everything that isn't a valid resource
    character; returns a shaped golem string.
    '''

    shapedGolem = []

    for piece in rawGolem:
        if piece in ['~', '@', '#', '^', '&', '*', '[', ']']:
            shapedGolem.append(piece)

    return "".join(shapedGolem)

## legacy functions

def newGolem(player, golemstring, time):
    '''
    Legacy golem creation method, left here for reference.
    '''

    golem = parse(golemstring)

    golemfile = open("../data/"+player+".golem", 'w+')
    golemfile.write(golemstring+"\n") # 0 golem string
    golemfile.write(j.join(golem)+"\n") # 1 golem stats
    golemfile.write(str(calcHeight(golem))+"\n") # 2 height
    golemfile.write(str(calcWidth(golem))+"\n") # 3 width
    golemfile.write(str(calcStrength(golem))+"\n") # 4 strength
    golemfile.write(str(calcInterval(golem))+"\n") # 5 interval
    golemfile.write(str(calcDeath(golem, time))+"\n") # 6 death time
    golemfile.write(str(time)+"\n") # 7 birth time
    golemfile.write(str(time)+"\n") # 8 last strike
    golemfile.write("0,0,0,0,0,0,0,0\n") # 9 held res

    golemfile.close()
    return golemstring


## legacy golem access commands

def parse(golemstring):
    '''
    Returns a reslist constructed from the specified golem string.
    '''

    golem = [0,0,0,0,0,0,0,0]
    components = list(golemstring)

    for x in components:
        if x == '~': golem[0] += 1
        elif x == '#': golem[1] += 1
        elif x == '@': golem[2] += 1
        elif x == '&': golem[3] += 1
        elif x == '*': golem[4] += 1
        elif x == '[': golem[5] += 1
        elif x == ']': golem[6] += 1
        elif x == '^': golem[7] += 1

    i = 0
    while i < 8: # stupid string hax
        r = str(golem[i])
        golem[i] = r
        i += 1

    return golem

## actions

def decay(player, pieces):
    golemdata = openGolem(player)
    golemshape = list(golemdata[0])

    i = 0
    while i < pieces:
        chunk = random.randrange(0,len(golemshape)-1)
        if golemshape[chunk] != " ":
            golemshape[chunk] = " "
            i += 1

    newshape = ''
    for x in golemshape:
        newshape += x
    golemdata[0] = newshape
    writeGolem(player, golemdata)

    return len(golemshape)-1
