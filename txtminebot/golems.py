#!/usr/bin/python

'''
This contains the class and functions for golems.

Golems are creatures that automatically strike at mines. To create one, a player
creates a golem shape by making ascii art with resources they currently have.
The golem's stats depend on its initial shape, with some amount of
randomization. Once created, a golem immediately begins working in the player's
currently targetted mine.

When the golem's lifespan ends, it crumbles, and all the resources it mined are
entered into the player's holdings.

Golems will never take mysterious smoke from the mines, nor will they switch
mines automatically.

Golem attributes:
    (given attributes)
    core: dict listing how many of each res went into creating it
    birth: int of birth timestamp
    owner: string of owner player name

    (calculated stats)
    interval: int of strike interval in seconds
    height: int of total size, which goes into strength calculation
    width: int of number of different res in core, which determines strike
        variety

    (rolled stats)
    strength: int of number of res per strike
    death: int of death timestamp

    (mutables)
    shape: string of original shape determined by player
    lastStrike: string of last strike timestamp
    res: 8-item int arrray of currently held resources (*)

(*): see mines.py documentation for reslist convention

plaintxtmines is a text-based multiplayer mining simulator. For more
information, see the full repository:

https://github.com/modgethanc/plaintxtmines
'''

__author__ = "Vincent Zeng (hvincent@modgethanc.com)"

import os
import random

import vtils

class Golem():
    '''
    Implements a golem object.
    '''

    def __init__ (self):
        '''
        Initial golem conditions.
        '''

        ## given stats
        self.core = None
        self.birth = None
        self.owner = None

        ## calculated stats
        self.interval = None
        self.height = None
        self.width = None

        ## depends on self.height
        self.strength = None

        ## depends on self.strength
        self.death = None

        ## mutables
        self.shape = ""
        self.lastStrike = 0
        self.res = [0,0,0,0,0,0,0,0]

    def load(self, player):
        '''
        Loads a golem from file for the named player, then returns that player's
        name to identify the new golem's owner.
        '''

        filename = player + ".golem"

        # hardcode bs
        golemData = vtils.open_json_as_dict("../data/"+filename)

        ## given stats
        self.core = golemData["core"]
        self.birth = golemData["birth"]
        self.owner = golemData["owner"]

        ## calculated stats
        self.interval = golemData["interval"]
        self.height = golemData["height"]
        self.width = golemData["width"]

        ## depends on self.height
        self.strength = golemData["strength"]

        ## depends on self.strength
        self.death = golemData["death"]

        ## mutables
        self.shape = golemData["shape"]
        self.lastStrike = golemData["lastStrike"]
        self.res = golemData["res"]

        return player

    def create(self, player_input, golemString):
        '''
        Create a new golem, using inputs from a player command.
        '''

        ## given stats
        self.core = self.parse(golemString)
        self.birth = player_input.timestamp
        self.owner = player_input.nick
        self.shape = golemString
        self.lastStrike = player_input.timestamp

        ## calculated stats
        self.interval = self.calc_interval()
        self.height = self.calc_height()
        self.width = self.calc_width()

        ## depends on self.height
        self.strength = self.calc_strength()

        ## depends on self.strength
        self.death = self.calc_death(self.birth)

    def save(self):
        '''
        Writes this golem to disk and returns its save location.
        '''

        # hardcode bs
        filename = "../data/" + self.owner + ".golem"
        golemData = self.to_dict()
        vtils.write_dict_as_json(filename, golemData)

        return filename

    def __str__(self):
        """Returns a string representation of this golem.
        """

        return "{shape} ({owner})".format(shape=self.shape, owner=self.owner)

    def to_dict(self):
        '''
        Turns all data into a dict.
        '''

        golemData = {
                "core": self.core,
                "birth": self.birth,
                "owner": self.owner,
                "interval": self.interval,
                "height": self.height,
                "width": self.width,
                "strength": self.strength,
                "death": self.death,
                "shape": self.shape,
                "lastStrike": self.lastStrike,
                "res": self.res
                }

        return golemData

    def parse(self, golemstring):
        '''
        Takes a golem string (usually generated by a player) and parses it into
        a dict that counts up each of the components of the golem.
        '''

        golemCore = {
                "~": 0,
                "#": 0,
                "@": 0,
                "&": 0,
                "*": 0,
                "[": 0,
                "]": 0,
                "^": 0
                }
        components = list(golemstring)

        for res in components:
            golemCore[res] += 1

        return golemCore

    ## stat formulas

    def calc_interval(self):
        '''
        Returns a strike interval roll between 1 and 200 seconds, based on the
        number of ampers in the golem.
        '''

        return 200/max(1, min(int(self.core["&"]), 100))

    def calc_height(self):
        '''
        Returns the height of the golem, which is just a sum of all of its
        parts.
        '''

        total = 0
        for res in iter(self.core):
            total += int(self.core[res])

        return total

    def calc_strength(self):
        '''
        Returns a strength roll for a golem, which is based on its height and
        the number of pounds it contains (to a maximum of 10 pounds).

        CAUTION: This assumes the height has already been set!
        '''

        return self.height * random.randrange(1, max(2, min(int(self.core["#"]), 10)))

    def calc_width(self):
        '''
        Returns the width of the golem, which is a count of how many different
        types of resources it contains.
        '''

        width = 0

        for res in self.core:
            if int(self.core[res]) > 0:
                width += 1

        return width

    def calc_death(self, timestamp):
        '''
        Takes a golem core and a timestamp and performs a diceroll to determine
        its lifespan, and returns a timestamp for when it will die. The golem's
        tail is based on the number of tildes it contains, which
        slightly influence its lifespan.

        CAUTION: This assums the strength has already been set!
        '''

        death = timestamp
        tail = int(self.core["~"]) * random.randrange(1,10)
        life = 100 * random.randrange(1, max(self.strength, 2)) + tail
        death = int(timestamp) + life

        return death

    ## inquiries

    def remaining_life(self, timestamp):
        '''
        Return the golem's remaining number of seconds until death.
        '''

        """ toggle for debug
        print "death: " + str(self.death)
        print "now:   " + str(timestamp)
        print "diff:  " + str(self.death-timestamp)
        """

        return self.death - int(timestamp)

    def is_alive(self, timestamp):
        '''
        Returns true if the golem is alive, false otherwise.
        '''

        return self.remaining_life(timestamp) > 0

    def readable_holdings(self):
        '''
        Returns a human-readable string of the golem's held resources.
        '''

        held = self.res

        return str(held[0])+ " tilde, "+str(held[1])+ " pound, "+str(held[2])+ " spiral, "+str(held[3])+ " amper, "+str(held[4])+ " splat, "+str(held[5])+ " lbrack, "+str(held[6])+ " rbrack, and "+str(held[7])+" carat, for a total of "+str(sum(held))+" units"
        #return held[0]+ " tilde, "+held[1]+ " pound, "+held[2]+ " spiral, "+held[3]+ " amper, "+held[4]+ " splat, "+held[5]+ " lbrack, "+held[6]+ " rbrack, and "+held[7]+" carat, for a total of "+str(heldTotal)+" units"

    ## actions

    def acquire(self, newRes):
        '''
        Adds new resources to golem's held.
        '''

        held = self.res

        print held

        for index, res in enumerate(newRes):
            held[index] += int(res)

        self.res = held
        self.save()

        return newRes

    def strike(self, targetMine, elapsed):
        '''
        Strikes at targeted mine and adds resources to own held, then updates
        last strike time and saves self to disk.
        '''

        excavation = targetMine.excavate(self.strength, self.width)
        held = self.res

        i = 0
        for resType in excavation:
            newTotal = int(held[i]) + int(resType)
            held[i] = newTotal
            i += 1

        self.lastStrike = elapsed
        self.save()

        return excavation

    def expire(self):
        '''
        Destroys this golem and returns a list of its resources.
        '''

        ## hardcoded
        os.remove("../data/"+self.owner+".golem")

        return self.res

    ## legacy

    def legacy_stats(self):
        '''
        Intermediate function, to return a string list of this golem's
        resources.
        '''
        return [
                self.core["~"],
                self.core["#"],
                self.core["@"],
                self.core["&"],
                self.core["*"],
                self.core["["],
                self.core["]"],
                self.core["^"]]

## golem helpers

def sift(rawGolem):
    '''
    Takes a raw golem and removes everything that isn't a valid resource
    character; returns a shaped golem string.
    '''

    shapedGolem = []

    for piece in rawGolem:
        if piece in ['~', '@', '#', '^', '&', '*', '[', ']']:
            shapedGolem.append(piece)

    return "".join(shapedGolem)

## legacy functions

    '''
    Legacy golem creation method, left here for reference.
def newGolem(player, golemstring, time):

    golem = parse(golemstring)

    golemfile = open("../data/"+player+".golem", 'w+')
    golemfile.write(golemstring+"\n") # 0 golem string
    golemfile.write(','.join(golem)+"\n") # 1 golem stats
    golemfile.write(str(calcHeight(golem))+"\n") # 2 height
    golemfile.write(str(calcWidth(golem))+"\n") # 3 width
    golemfile.write(str(calcStrength(golem))+"\n") # 4 strength
    golemfile.write(str(calcInterval(golem))+"\n") # 5 interval
    golemfile.write(str(calcDeath(golem, time))+"\n") # 6 death time
    golemfile.write(str(time)+"\n") # 7 birth time
    golemfile.write(str(time)+"\n") # 8 last strike
    golemfile.write("0,0,0,0,0,0,0,0\n") # 9 held res

    golemfile.close()
    return golemstring

    '''

## legacy golem access commands

def parse(golemstring):
    '''
    Returns a reslist constructed from the specified golem string.
    '''

    golem = [0,0,0,0,0,0,0,0]
    components = list(golemstring)

    for x in components:
        if x == '~': golem[0] += 1
        elif x == '#': golem[1] += 1
        elif x == '@': golem[2] += 1
        elif x == '&': golem[3] += 1
        elif x == '*': golem[4] += 1
        elif x == '[': golem[5] += 1
        elif x == ']': golem[6] += 1
        elif x == '^': golem[7] += 1
    """
    i = 0
    while i < 8: # stupid string hax
        r = str(golem[i])
        golem[i] = r
        i += 1
        """

    return golem

## actions

def decay(player, pieces):
    golemdata = openGolem(player)
    golemshape = list(golemdata[0])

    i = 0
    while i < pieces:
        chunk = random.randrange(0,len(golemshape)-1)
        if golemshape[chunk] != " ":
            golemshape[chunk] = " "
            i += 1

    newshape = ''
    for x in golemshape:
        newshape += x
    golemdata[0] = newshape
    writeGolem(player, golemdata)

    return len(golemshape)-1
