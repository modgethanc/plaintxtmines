#!/usr/bin/python

'''
This contains the class and functions for golems.

Golems are creatures that automatically strike at mines. To create one, a player
creates a golem shape by making ascii art with resources they currently have.
The golem's stats depend on its initial shape, with some amount of
randomization. Once created, a golem immediately begins working in the player's
currently targetted mine.

When the golem's lifespan ends, it crumbles, and all the resources it mined are
entered into the player's holdings.

Golems will never take mysterious smoke from the mines, nor will they switch
mines automatically.

plaintxtmines is a text-based multiplayer mining simulator. For more
information, see the full repository:

https://github.com/modgethanc/plaintxtmines
'''

__author__ = "Vincent Zeng (hvincent@modgethanc.com)"

import os
import random

import players
import mines

j = ','

class Golem():
    '''
    Implements a golem object.
    '''

    def __init__ (self):
        '''
        Initial golem conditions.
        '''

        ## given stats
        self.core = None
        self.birth = None
        self.owner = None

        ## calculated stats
        self.interval = None
        self.height = None
        self.width = None

        ## depends on self.height
        self.strength = None

        ## depends on self.strength
        self.death = None

        ## mutables
        self.shape = ""
        self.lastStrike = 0
        self.res = "0,0,0,0,0,0,0,0"


    def load(self, player_input):
        '''
        Loads a golem from file.
        '''

        filename = player_input.nick + ".golem"

        golemData = {}

        return

    def create(self, player_input, golemString):
        '''
        Create a new golem, using inputs from a player command.
        '''

        ## given stats
        self.core = self.parse(golemString)
        self.birth = player_input.timestamp
        self.owner = player_input.nick
        self.shape = golemString

        ## calculated stats
        self.interval = self.calc_interval()
        self.height = self.calc_height()
        self.width = self.calc_width()

        ## depends on self.height
        self.strength = self.calc_strength()

        ## depends on self.strength
        self.death = self.calc_death(self.birth)

    def save(self):
        '''
        Writes this golem to disk.
        '''

        filename = self.owner + ".golem"
        golemData = self.to_dict()

        # then write file

        return

    def to_dict(self):
        '''
        Turns all data into a dict.
        '''

        golemData = {
                "core": self.core,
                "birth": self.birth,
                "owner": self.owner,
                "interval": self.interval,
                "height": self.height,
                "width": self.width,
                "strength": self.strength,
                "death": self.death,
                "shape": self.shape,
                "lastStrike": self.lastStrike,
                "res": self.red
                }

        return golemData

    def parse(self, golemstring):
        '''
        Takes a golem string (usually generated by a player) and parses it into
        a dict that counts up each of the components of the golem.
        '''

        golemCore = {
                "~": 0,
                "#": 0,
                "@": 0,
                "&": 0,
                "*": 0,
                "[": 0,
                "]": 0,
                "^": 0
                }
        components = list(golemstring)

        for res in components:
            golemCore[res] += 1

        return golemCore

    ## stat formulas

    def calc_interval(self):
        '''
        Returns a strike interval roll between 1 and 200 seconds, based on the
        number of ampers in the golem.
        '''

        return 200/max(1, min(int(self.core["&"]), 100))

    def calc_height(self):
        '''
        Returns the height of the golem, which is just a sum of all of its
        parts.
        '''

        total = 0
        for res in iter(self.core):
            total += int(self.core[res])

        return total

    def calc_strength(self):
        '''
        Returns a strength roll for a golem, which is based on its height and
        the number of pounds it contains (to a maximum of 10 pounds).

        CAUTION: This assumes the height has already been set!
        '''

        return self.height * random.randrange(1, max(2, min(int(self.core["#"]), 10)))

    def calc_width(self):
        '''
        Returns the width of the golem, which is a count of how many different
        types of resources it contains.
        '''

        width = 0

        for res in self.core:
            if int(self.core[res]) > 0:
                width += 1

        return width

    def calc_death(self, timestamp):
        '''
        Takes a golem core and a timestamp and performs a diceroll to determine
        its lifespan, and returns a timestamp for when it will die. The golem's
        tail is based on the number of tildes it contains, which
        slightly influence its lifespan.

        CAUTION: This assums the strength has already been set!
        '''

        death = timestamp
        tail = int(self.core["~"]) * random.randrange(1,10)
        life = 100 * random.randrange(1, max(self.strength, 2)) + tail
        death = int(timestamp) + life

        return death

    ## inquiries

    def remaining_life(self, timestamp):
        '''
        Return the golem's remaining number of seconds until death.
        '''

        return self.death - int(timestamp)

    def readable_holdings(self):
        '''
        Returns a human-readable string of the golem's held resources.
        '''

        held = self.res.split(",")

        heldTotal = 0
        for res in held:
            heldTotal += int(res)

        return held[0]+ " tilde, "+held[1]+ " pound, "+held[2]+ " spiral, "+held[3]+ " amper, "+held[4]+ " splat, "+held[5]+ " lbrack, "+held[6]+ " rbrack, and "+held[7]+" carat, for a total of "+str(heldTotal)+" units"

    def legacy_stats(self):
        '''
        Intermediate function, to return a string list of this golem's
        resources.
        '''

        '''
        return ",".join([
                str(self.core["~"]),
                str(self.core["@"]),
                str(self.core["#"]),
                str(self.core["&"]),
                str(self.core["&"]),
                str(self.core["*"]),
                str(self.core["["]),
                str(self.core["]"])])
        '''
        return [
                self.core["~"],
                self.core["@"],
                self.core["#"],
                self.core["&"],
                self.core["&"],
                self.core["*"],
                self.core["["],
                self.core["]"]]

## golem helpers

def sift(rawGolem):
    '''
    Takes a raw golem and removes everything that isn't a valid resource
    character; returns a shaped golem string.
    '''

    shapedGolem = []

    for piece in rawGolem:
        if piece in ['~', '@', '#', '^', '&', '*', '[', ']']:
            shapedGolem.append(piece)

    return "".join(shapedGolem)

## legacy functions

def newGolem(player, golemstring, time):
    '''
    Legacy golem creation method, left here for reference.
    '''

    golem = parse(golemstring)

    golemfile = open("../data/"+player+".golem", 'w+')
    golemfile.write(golemstring+"\n") # 0 golem string
    golemfile.write(j.join(golem)+"\n") # 1 golem stats
    golemfile.write(str(calcHeight(golem))+"\n") # 2 height
    golemfile.write(str(calcWidth(golem))+"\n") # 3 width
    golemfile.write(str(calcStrength(golem))+"\n") # 4 strength
    golemfile.write(str(calcInterval(golem))+"\n") # 5 interval
    golemfile.write(str(calcDeath(golem, time))+"\n") # 6 death time
    golemfile.write(str(time)+"\n") # 7 birth time
    golemfile.write(str(time)+"\n") # 8 last strike
    golemfile.write("0,0,0,0,0,0,0,0\n") # 9 held res

    golemfile.close()
    return golemstring


## legacy golem access commands

def parse(golemstring):
    '''
    Returns a reslist constructed from the specified golem string.
    '''

    golem = [0,0,0,0,0,0,0,0]
    components = list(golemstring)

    for x in components:
        if x == '~': golem[0] += 1
        elif x == '#': golem[1] += 1
        elif x == '@': golem[2] += 1
        elif x == '&': golem[3] += 1
        elif x == '*': golem[4] += 1
        elif x == '[': golem[5] += 1
        elif x == ']': golem[6] += 1
        elif x == '^': golem[7] += 1

    i = 0
    while i < 8: # stupid string hax
        r = str(golem[i])
        golem[i] = r
        i += 1

    return golem


### golem outputting

def openGolem(player):
    golemfile = open('../data/'+player+'.golem', 'r')
    golemdata = []
    for x in golemfile:
        golemdata.append(x.rstrip())
    golemfile.close()

    return golemdata

def getDeath(player): # return int of death time
    return int(openGolem(player)[6])

def getLastStrike(player): # return int of birth time
    return int(openGolem(player)[8])

## golem updating

def writeGolem(player, golemdata):
    golemfile = open('../data/'+player+'.golem', 'w')
    for x in golemdata:
        golemfile.write(str(x) + "\n")
    golemfile.close()

def updateLastStrike(player, time):
    golemdata = openGolem(player)
    golemdata[8] = time
    writeGolem(player, golemdata)

    return time

## actions

def strike(player, target): # performs mining action
    excavation = mines.excavate(target, getStrength(player), getWidth(player))
    held = getHeld(player)

    i = 0
    for x in excavation:
        r = int(held[i]) + int(x)
        held[i] = str(r)
        i += 1

    golemdata = openGolem(player)
    golemdata[9] = j.join(held)

    writeGolem(player, golemdata)

    ## 10/31/17 disabling decay because it's hanging
    #if random.randrange(1,100) < 15:
    #    print decay(player, 1)

    return excavation

def decay(player, pieces):
    golemdata = openGolem(player)
    golemshape = list(golemdata[0])

    i = 0
    while i < pieces:
        chunk = random.randrange(0,len(golemshape)-1)
        if golemshape[chunk] != " ":
            golemshape[chunk] = " "
            i += 1

    newshape = ''
    for x in golemshape:
        newshape += x
    golemdata[0] = newshape
    writeGolem(player, golemdata)

    return len(golemshape)-1

def expire(player):
    golemheld = getHeld(player)
    os.remove("../data/"+player+".golem")
    players.acquireRes(player, golemheld)

    return golemheld
